{"ast":null,"code":"/*jshint node:true */\nvar assert = require('assert');\n\nexports.HTTPParser = HTTPParser;\n\nfunction HTTPParser(type) {\n  assert.ok(type === HTTPParser.REQUEST || type === HTTPParser.RESPONSE || type === undefined);\n\n  if (type === undefined) {// Node v12+\n  } else {\n    this.initialize(type);\n  }\n}\n\nHTTPParser.prototype.initialize = function (type, async_resource) {\n  assert.ok(type === HTTPParser.REQUEST || type === HTTPParser.RESPONSE);\n  this.type = type;\n  this.state = type + '_LINE';\n  this.info = {\n    headers: [],\n    upgrade: false\n  };\n  this.trailers = [];\n  this.line = '';\n  this.isChunked = false;\n  this.connection = '';\n  this.headerSize = 0; // for preventing too big headers\n\n  this.body_bytes = null;\n  this.isUserCall = false;\n  this.hadError = false;\n};\n\nHTTPParser.encoding = 'ascii';\nHTTPParser.maxHeaderSize = 80 * 1024; // maxHeaderSize (in bytes) is configurable, but 80kb by default;\n\nHTTPParser.REQUEST = 'REQUEST';\nHTTPParser.RESPONSE = 'RESPONSE'; // Note: *not* starting with kOnHeaders=0 line the Node parser, because any\n//   newly added constants (kOnTimeout in Node v12.19.0) will overwrite 0!\n\nvar kOnHeaders = HTTPParser.kOnHeaders = 1;\nvar kOnHeadersComplete = HTTPParser.kOnHeadersComplete = 2;\nvar kOnBody = HTTPParser.kOnBody = 3;\nvar kOnMessageComplete = HTTPParser.kOnMessageComplete = 4; // Some handler stubs, needed for compatibility\n\nHTTPParser.prototype[kOnHeaders] = HTTPParser.prototype[kOnHeadersComplete] = HTTPParser.prototype[kOnBody] = HTTPParser.prototype[kOnMessageComplete] = function () {};\n\nvar compatMode0_12 = true;\nObject.defineProperty(HTTPParser, 'kOnExecute', {\n  get: function () {\n    // hack for backward compatibility\n    compatMode0_12 = false;\n    return 99;\n  }\n});\nvar methods = exports.methods = HTTPParser.methods = ['DELETE', 'GET', 'HEAD', 'POST', 'PUT', 'CONNECT', 'OPTIONS', 'TRACE', 'COPY', 'LOCK', 'MKCOL', 'MOVE', 'PROPFIND', 'PROPPATCH', 'SEARCH', 'UNLOCK', 'BIND', 'REBIND', 'UNBIND', 'ACL', 'REPORT', 'MKACTIVITY', 'CHECKOUT', 'MERGE', 'M-SEARCH', 'NOTIFY', 'SUBSCRIBE', 'UNSUBSCRIBE', 'PATCH', 'PURGE', 'MKCALENDAR', 'LINK', 'UNLINK'];\nvar method_connect = methods.indexOf('CONNECT');\nHTTPParser.prototype.reinitialize = HTTPParser;\n\nHTTPParser.prototype.close = HTTPParser.prototype.pause = HTTPParser.prototype.resume = HTTPParser.prototype.free = function () {};\n\nHTTPParser.prototype._compatMode0_11 = false;\n\nHTTPParser.prototype.getAsyncId = function () {\n  return 0;\n};\n\nvar headerState = {\n  REQUEST_LINE: true,\n  RESPONSE_LINE: true,\n  HEADER: true\n};\n\nHTTPParser.prototype.execute = function (chunk, start, length) {\n  if (!(this instanceof HTTPParser)) {\n    throw new TypeError('not a HTTPParser');\n  } // backward compat to node < 0.11.4\n  // Note: the start and length params were removed in newer version\n\n\n  start = start || 0;\n  length = typeof length === 'number' ? length : chunk.length;\n  this.chunk = chunk;\n  this.offset = start;\n  var end = this.end = start + length;\n\n  try {\n    while (this.offset < end) {\n      if (this[this.state]()) {\n        break;\n      }\n    }\n  } catch (err) {\n    if (this.isUserCall) {\n      throw err;\n    }\n\n    this.hadError = true;\n    return err;\n  }\n\n  this.chunk = null;\n  length = this.offset - start;\n\n  if (headerState[this.state]) {\n    this.headerSize += length;\n\n    if (this.headerSize > HTTPParser.maxHeaderSize) {\n      return new Error('max header size exceeded');\n    }\n  }\n\n  return length;\n};\n\nvar stateFinishAllowed = {\n  REQUEST_LINE: true,\n  RESPONSE_LINE: true,\n  BODY_RAW: true\n};\n\nHTTPParser.prototype.finish = function () {\n  if (this.hadError) {\n    return;\n  }\n\n  if (!stateFinishAllowed[this.state]) {\n    return new Error('invalid state for EOF');\n  }\n\n  if (this.state === 'BODY_RAW') {\n    this.userCall()(this[kOnMessageComplete]());\n  }\n}; // These three methods are used for an internal speed optimization, and it also\n// works if theses are noops. Basically consume() asks us to read the bytes\n// ourselves, but if we don't do it we get them through execute().\n\n\nHTTPParser.prototype.consume = HTTPParser.prototype.unconsume = HTTPParser.prototype.getCurrentBuffer = function () {}; //For correct error handling - see HTTPParser#execute\n//Usage: this.userCall()(userFunction('arg'));\n\n\nHTTPParser.prototype.userCall = function () {\n  this.isUserCall = true;\n  var self = this;\n  return function (ret) {\n    self.isUserCall = false;\n    return ret;\n  };\n};\n\nHTTPParser.prototype.nextRequest = function () {\n  this.userCall()(this[kOnMessageComplete]());\n  this.reinitialize(this.type);\n};\n\nHTTPParser.prototype.consumeLine = function () {\n  var end = this.end,\n      chunk = this.chunk;\n\n  for (var i = this.offset; i < end; i++) {\n    if (chunk[i] === 0x0a) {\n      // \\n\n      var line = this.line + chunk.toString(HTTPParser.encoding, this.offset, i);\n\n      if (line.charAt(line.length - 1) === '\\r') {\n        line = line.substr(0, line.length - 1);\n      }\n\n      this.line = '';\n      this.offset = i + 1;\n      return line;\n    }\n  } //line split over multiple chunks\n\n\n  this.line += chunk.toString(HTTPParser.encoding, this.offset, this.end);\n  this.offset = this.end;\n};\n\nvar headerExp = /^([^: \\t]+):[ \\t]*((?:.*[^ \\t])|)/;\nvar headerContinueExp = /^[ \\t]+(.*[^ \\t])/;\n\nHTTPParser.prototype.parseHeader = function (line, headers) {\n  if (line.indexOf('\\r') !== -1) {\n    throw parseErrorCode('HPE_LF_EXPECTED');\n  }\n\n  var match = headerExp.exec(line);\n  var k = match && match[1];\n\n  if (k) {\n    // skip empty string (malformed header)\n    headers.push(k);\n    headers.push(match[2]);\n  } else {\n    var matchContinue = headerContinueExp.exec(line);\n\n    if (matchContinue && headers.length) {\n      if (headers[headers.length - 1]) {\n        headers[headers.length - 1] += ' ';\n      }\n\n      headers[headers.length - 1] += matchContinue[1];\n    }\n  }\n};\n\nvar requestExp = /^([A-Z-]+) ([^ ]+) HTTP\\/(\\d)\\.(\\d)$/;\n\nHTTPParser.prototype.REQUEST_LINE = function () {\n  var line = this.consumeLine();\n\n  if (!line) {\n    return;\n  }\n\n  var match = requestExp.exec(line);\n\n  if (match === null) {\n    throw parseErrorCode('HPE_INVALID_CONSTANT');\n  }\n\n  this.info.method = this._compatMode0_11 ? match[1] : methods.indexOf(match[1]);\n\n  if (this.info.method === -1) {\n    throw new Error('invalid request method');\n  }\n\n  this.info.url = match[2];\n  this.info.versionMajor = +match[3];\n  this.info.versionMinor = +match[4];\n  this.body_bytes = 0;\n  this.state = 'HEADER';\n};\n\nvar responseExp = /^HTTP\\/(\\d)\\.(\\d) (\\d{3}) ?(.*)$/;\n\nHTTPParser.prototype.RESPONSE_LINE = function () {\n  var line = this.consumeLine();\n\n  if (!line) {\n    return;\n  }\n\n  var match = responseExp.exec(line);\n\n  if (match === null) {\n    throw parseErrorCode('HPE_INVALID_CONSTANT');\n  }\n\n  this.info.versionMajor = +match[1];\n  this.info.versionMinor = +match[2];\n  var statusCode = this.info.statusCode = +match[3];\n  this.info.statusMessage = match[4]; // Implied zero length.\n\n  if ((statusCode / 100 | 0) === 1 || statusCode === 204 || statusCode === 304) {\n    this.body_bytes = 0;\n  }\n\n  this.state = 'HEADER';\n};\n\nHTTPParser.prototype.shouldKeepAlive = function () {\n  if (this.info.versionMajor > 0 && this.info.versionMinor > 0) {\n    if (this.connection.indexOf('close') !== -1) {\n      return false;\n    }\n  } else if (this.connection.indexOf('keep-alive') === -1) {\n    return false;\n  }\n\n  if (this.body_bytes !== null || this.isChunked) {\n    // || skipBody\n    return true;\n  }\n\n  return false;\n};\n\nHTTPParser.prototype.HEADER = function () {\n  var line = this.consumeLine();\n\n  if (line === undefined) {\n    return;\n  }\n\n  var info = this.info;\n\n  if (line) {\n    this.parseHeader(line, info.headers);\n  } else {\n    var headers = info.headers;\n    var hasContentLength = false;\n    var currentContentLengthValue;\n    var hasUpgradeHeader = false;\n\n    for (var i = 0; i < headers.length; i += 2) {\n      switch (headers[i].toLowerCase()) {\n        case 'transfer-encoding':\n          this.isChunked = headers[i + 1].toLowerCase() === 'chunked';\n          break;\n\n        case 'content-length':\n          currentContentLengthValue = +headers[i + 1];\n\n          if (hasContentLength) {\n            // Fix duplicate Content-Length header with same values.\n            // Throw error only if values are different.\n            // Known issues:\n            // https://github.com/request/request/issues/2091#issuecomment-328715113\n            // https://github.com/nodejs/node/issues/6517#issuecomment-216263771\n            if (currentContentLengthValue !== this.body_bytes) {\n              throw parseErrorCode('HPE_UNEXPECTED_CONTENT_LENGTH');\n            }\n          } else {\n            hasContentLength = true;\n            this.body_bytes = currentContentLengthValue;\n          }\n\n          break;\n\n        case 'connection':\n          this.connection += headers[i + 1].toLowerCase();\n          break;\n\n        case 'upgrade':\n          hasUpgradeHeader = true;\n          break;\n      }\n    } // if both isChunked and hasContentLength, isChunked wins\n    // This is required so the body is parsed using the chunked method, and matches\n    // Chrome's behavior.  We could, maybe, ignore them both (would get chunked\n    // encoding into the body), and/or disable shouldKeepAlive to be more\n    // resilient.\n\n\n    if (this.isChunked && hasContentLength) {\n      hasContentLength = false;\n      this.body_bytes = null;\n    } // Logic from https://github.com/nodejs/http-parser/blob/921d5585515a153fa00e411cf144280c59b41f90/http_parser.c#L1727-L1737\n    // \"For responses, \"Upgrade: foo\" and \"Connection: upgrade\" are\n    //   mandatory only when it is a 101 Switching Protocols response,\n    //   otherwise it is purely informational, to announce support.\n\n\n    if (hasUpgradeHeader && this.connection.indexOf('upgrade') != -1) {\n      info.upgrade = this.type === HTTPParser.REQUEST || info.statusCode === 101;\n    } else {\n      info.upgrade = info.method === method_connect;\n    }\n\n    if (this.isChunked && info.upgrade) {\n      this.isChunked = false;\n    }\n\n    info.shouldKeepAlive = this.shouldKeepAlive(); //problem which also exists in original node: we should know skipBody before calling onHeadersComplete\n\n    var skipBody;\n\n    if (compatMode0_12) {\n      skipBody = this.userCall()(this[kOnHeadersComplete](info));\n    } else {\n      skipBody = this.userCall()(this[kOnHeadersComplete](info.versionMajor, info.versionMinor, info.headers, info.method, info.url, info.statusCode, info.statusMessage, info.upgrade, info.shouldKeepAlive));\n    }\n\n    if (skipBody === 2) {\n      this.nextRequest();\n      return true;\n    } else if (this.isChunked && !skipBody) {\n      this.state = 'BODY_CHUNKHEAD';\n    } else if (skipBody || this.body_bytes === 0) {\n      this.nextRequest(); // For older versions of node (v6.x and older?), that return skipBody=1 or skipBody=true,\n      //   need this \"return true;\" if it's an upgrade request.\n\n      return info.upgrade;\n    } else if (this.body_bytes === null) {\n      this.state = 'BODY_RAW';\n    } else {\n      this.state = 'BODY_SIZED';\n    }\n  }\n};\n\nHTTPParser.prototype.BODY_CHUNKHEAD = function () {\n  var line = this.consumeLine();\n\n  if (line === undefined) {\n    return;\n  }\n\n  this.body_bytes = parseInt(line, 16);\n\n  if (!this.body_bytes) {\n    this.state = 'BODY_CHUNKTRAILERS';\n  } else {\n    this.state = 'BODY_CHUNK';\n  }\n};\n\nHTTPParser.prototype.BODY_CHUNK = function () {\n  var length = Math.min(this.end - this.offset, this.body_bytes);\n  this.userCall()(this[kOnBody](this.chunk, this.offset, length));\n  this.offset += length;\n  this.body_bytes -= length;\n\n  if (!this.body_bytes) {\n    this.state = 'BODY_CHUNKEMPTYLINE';\n  }\n};\n\nHTTPParser.prototype.BODY_CHUNKEMPTYLINE = function () {\n  var line = this.consumeLine();\n\n  if (line === undefined) {\n    return;\n  }\n\n  assert.equal(line, '');\n  this.state = 'BODY_CHUNKHEAD';\n};\n\nHTTPParser.prototype.BODY_CHUNKTRAILERS = function () {\n  var line = this.consumeLine();\n\n  if (line === undefined) {\n    return;\n  }\n\n  if (line) {\n    this.parseHeader(line, this.trailers);\n  } else {\n    if (this.trailers.length) {\n      this.userCall()(this[kOnHeaders](this.trailers, ''));\n    }\n\n    this.nextRequest();\n  }\n};\n\nHTTPParser.prototype.BODY_RAW = function () {\n  var length = this.end - this.offset;\n  this.userCall()(this[kOnBody](this.chunk, this.offset, length));\n  this.offset = this.end;\n};\n\nHTTPParser.prototype.BODY_SIZED = function () {\n  var length = Math.min(this.end - this.offset, this.body_bytes);\n  this.userCall()(this[kOnBody](this.chunk, this.offset, length));\n  this.offset += length;\n  this.body_bytes -= length;\n\n  if (!this.body_bytes) {\n    this.nextRequest();\n  }\n}; // backward compat to node < 0.11.6\n\n\n['Headers', 'HeadersComplete', 'Body', 'MessageComplete'].forEach(function (name) {\n  var k = HTTPParser['kOn' + name];\n  Object.defineProperty(HTTPParser.prototype, 'on' + name, {\n    get: function () {\n      return this[k];\n    },\n    set: function (to) {\n      // hack for backward compatibility\n      this._compatMode0_11 = true;\n      method_connect = 'CONNECT';\n      return this[k] = to;\n    }\n  });\n});\n\nfunction parseErrorCode(code) {\n  var err = new Error('Parse Error');\n  err.code = code;\n  return err;\n}","map":{"version":3,"names":["assert","require","exports","HTTPParser","type","ok","REQUEST","RESPONSE","undefined","initialize","prototype","async_resource","state","info","headers","upgrade","trailers","line","isChunked","connection","headerSize","body_bytes","isUserCall","hadError","encoding","maxHeaderSize","kOnHeaders","kOnHeadersComplete","kOnBody","kOnMessageComplete","compatMode0_12","Object","defineProperty","get","methods","method_connect","indexOf","reinitialize","close","pause","resume","free","_compatMode0_11","getAsyncId","headerState","REQUEST_LINE","RESPONSE_LINE","HEADER","execute","chunk","start","length","TypeError","offset","end","err","Error","stateFinishAllowed","BODY_RAW","finish","userCall","consume","unconsume","getCurrentBuffer","self","ret","nextRequest","consumeLine","i","toString","charAt","substr","headerExp","headerContinueExp","parseHeader","parseErrorCode","match","exec","k","push","matchContinue","requestExp","method","url","versionMajor","versionMinor","responseExp","statusCode","statusMessage","shouldKeepAlive","hasContentLength","currentContentLengthValue","hasUpgradeHeader","toLowerCase","skipBody","BODY_CHUNKHEAD","parseInt","BODY_CHUNK","Math","min","BODY_CHUNKEMPTYLINE","equal","BODY_CHUNKTRAILERS","BODY_SIZED","forEach","name","set","to","code"],"sources":["/home/faisal/ServerExample/client/client/node_modules/http-parser-js/http-parser.js"],"sourcesContent":["/*jshint node:true */\n\nvar assert = require('assert');\n\nexports.HTTPParser = HTTPParser;\nfunction HTTPParser(type) {\n  assert.ok(type === HTTPParser.REQUEST || type === HTTPParser.RESPONSE || type === undefined);\n  if (type === undefined) {\n    // Node v12+\n  } else {\n    this.initialize(type);\n  }\n}\nHTTPParser.prototype.initialize = function (type, async_resource) {\n  assert.ok(type === HTTPParser.REQUEST || type === HTTPParser.RESPONSE);\n  this.type = type;\n  this.state = type + '_LINE';\n  this.info = {\n    headers: [],\n    upgrade: false\n  };\n  this.trailers = [];\n  this.line = '';\n  this.isChunked = false;\n  this.connection = '';\n  this.headerSize = 0; // for preventing too big headers\n  this.body_bytes = null;\n  this.isUserCall = false;\n  this.hadError = false;\n};\n\nHTTPParser.encoding = 'ascii';\nHTTPParser.maxHeaderSize = 80 * 1024; // maxHeaderSize (in bytes) is configurable, but 80kb by default;\nHTTPParser.REQUEST = 'REQUEST';\nHTTPParser.RESPONSE = 'RESPONSE';\n\n// Note: *not* starting with kOnHeaders=0 line the Node parser, because any\n//   newly added constants (kOnTimeout in Node v12.19.0) will overwrite 0!\nvar kOnHeaders = HTTPParser.kOnHeaders = 1;\nvar kOnHeadersComplete = HTTPParser.kOnHeadersComplete = 2;\nvar kOnBody = HTTPParser.kOnBody = 3;\nvar kOnMessageComplete = HTTPParser.kOnMessageComplete = 4;\n\n// Some handler stubs, needed for compatibility\nHTTPParser.prototype[kOnHeaders] =\nHTTPParser.prototype[kOnHeadersComplete] =\nHTTPParser.prototype[kOnBody] =\nHTTPParser.prototype[kOnMessageComplete] = function () {};\n\nvar compatMode0_12 = true;\nObject.defineProperty(HTTPParser, 'kOnExecute', {\n    get: function () {\n      // hack for backward compatibility\n      compatMode0_12 = false;\n      return 99;\n    }\n  });\n\nvar methods = exports.methods = HTTPParser.methods = [\n  'DELETE',\n  'GET',\n  'HEAD',\n  'POST',\n  'PUT',\n  'CONNECT',\n  'OPTIONS',\n  'TRACE',\n  'COPY',\n  'LOCK',\n  'MKCOL',\n  'MOVE',\n  'PROPFIND',\n  'PROPPATCH',\n  'SEARCH',\n  'UNLOCK',\n  'BIND',\n  'REBIND',\n  'UNBIND',\n  'ACL',\n  'REPORT',\n  'MKACTIVITY',\n  'CHECKOUT',\n  'MERGE',\n  'M-SEARCH',\n  'NOTIFY',\n  'SUBSCRIBE',\n  'UNSUBSCRIBE',\n  'PATCH',\n  'PURGE',\n  'MKCALENDAR',\n  'LINK',\n  'UNLINK'\n];\nvar method_connect = methods.indexOf('CONNECT');\nHTTPParser.prototype.reinitialize = HTTPParser;\nHTTPParser.prototype.close =\nHTTPParser.prototype.pause =\nHTTPParser.prototype.resume =\nHTTPParser.prototype.free = function () {};\nHTTPParser.prototype._compatMode0_11 = false;\nHTTPParser.prototype.getAsyncId = function() { return 0; };\n\nvar headerState = {\n  REQUEST_LINE: true,\n  RESPONSE_LINE: true,\n  HEADER: true\n};\nHTTPParser.prototype.execute = function (chunk, start, length) {\n  if (!(this instanceof HTTPParser)) {\n    throw new TypeError('not a HTTPParser');\n  }\n\n  // backward compat to node < 0.11.4\n  // Note: the start and length params were removed in newer version\n  start = start || 0;\n  length = typeof length === 'number' ? length : chunk.length;\n\n  this.chunk = chunk;\n  this.offset = start;\n  var end = this.end = start + length;\n  try {\n    while (this.offset < end) {\n      if (this[this.state]()) {\n        break;\n      }\n    }\n  } catch (err) {\n    if (this.isUserCall) {\n      throw err;\n    }\n    this.hadError = true;\n    return err;\n  }\n  this.chunk = null;\n  length = this.offset - start;\n  if (headerState[this.state]) {\n    this.headerSize += length;\n    if (this.headerSize > HTTPParser.maxHeaderSize) {\n      return new Error('max header size exceeded');\n    }\n  }\n  return length;\n};\n\nvar stateFinishAllowed = {\n  REQUEST_LINE: true,\n  RESPONSE_LINE: true,\n  BODY_RAW: true\n};\nHTTPParser.prototype.finish = function () {\n  if (this.hadError) {\n    return;\n  }\n  if (!stateFinishAllowed[this.state]) {\n    return new Error('invalid state for EOF');\n  }\n  if (this.state === 'BODY_RAW') {\n    this.userCall()(this[kOnMessageComplete]());\n  }\n};\n\n// These three methods are used for an internal speed optimization, and it also\n// works if theses are noops. Basically consume() asks us to read the bytes\n// ourselves, but if we don't do it we get them through execute().\nHTTPParser.prototype.consume =\nHTTPParser.prototype.unconsume =\nHTTPParser.prototype.getCurrentBuffer = function () {};\n\n//For correct error handling - see HTTPParser#execute\n//Usage: this.userCall()(userFunction('arg'));\nHTTPParser.prototype.userCall = function () {\n  this.isUserCall = true;\n  var self = this;\n  return function (ret) {\n    self.isUserCall = false;\n    return ret;\n  };\n};\n\nHTTPParser.prototype.nextRequest = function () {\n  this.userCall()(this[kOnMessageComplete]());\n  this.reinitialize(this.type);\n};\n\nHTTPParser.prototype.consumeLine = function () {\n  var end = this.end,\n      chunk = this.chunk;\n  for (var i = this.offset; i < end; i++) {\n    if (chunk[i] === 0x0a) { // \\n\n      var line = this.line + chunk.toString(HTTPParser.encoding, this.offset, i);\n      if (line.charAt(line.length - 1) === '\\r') {\n        line = line.substr(0, line.length - 1);\n      }\n      this.line = '';\n      this.offset = i + 1;\n      return line;\n    }\n  }\n  //line split over multiple chunks\n  this.line += chunk.toString(HTTPParser.encoding, this.offset, this.end);\n  this.offset = this.end;\n};\n\nvar headerExp = /^([^: \\t]+):[ \\t]*((?:.*[^ \\t])|)/;\nvar headerContinueExp = /^[ \\t]+(.*[^ \\t])/;\nHTTPParser.prototype.parseHeader = function (line, headers) {\n  if (line.indexOf('\\r') !== -1) {\n    throw parseErrorCode('HPE_LF_EXPECTED');\n  }\n\n  var match = headerExp.exec(line);\n  var k = match && match[1];\n  if (k) { // skip empty string (malformed header)\n    headers.push(k);\n    headers.push(match[2]);\n  } else {\n    var matchContinue = headerContinueExp.exec(line);\n    if (matchContinue && headers.length) {\n      if (headers[headers.length - 1]) {\n        headers[headers.length - 1] += ' ';\n      }\n      headers[headers.length - 1] += matchContinue[1];\n    }\n  }\n};\n\nvar requestExp = /^([A-Z-]+) ([^ ]+) HTTP\\/(\\d)\\.(\\d)$/;\nHTTPParser.prototype.REQUEST_LINE = function () {\n  var line = this.consumeLine();\n  if (!line) {\n    return;\n  }\n  var match = requestExp.exec(line);\n  if (match === null) {\n    throw parseErrorCode('HPE_INVALID_CONSTANT');\n  }\n  this.info.method = this._compatMode0_11 ? match[1] : methods.indexOf(match[1]);\n  if (this.info.method === -1) {\n    throw new Error('invalid request method');\n  }\n  this.info.url = match[2];\n  this.info.versionMajor = +match[3];\n  this.info.versionMinor = +match[4];\n  this.body_bytes = 0;\n  this.state = 'HEADER';\n};\n\nvar responseExp = /^HTTP\\/(\\d)\\.(\\d) (\\d{3}) ?(.*)$/;\nHTTPParser.prototype.RESPONSE_LINE = function () {\n  var line = this.consumeLine();\n  if (!line) {\n    return;\n  }\n  var match = responseExp.exec(line);\n  if (match === null) {\n    throw parseErrorCode('HPE_INVALID_CONSTANT');\n  }\n  this.info.versionMajor = +match[1];\n  this.info.versionMinor = +match[2];\n  var statusCode = this.info.statusCode = +match[3];\n  this.info.statusMessage = match[4];\n  // Implied zero length.\n  if ((statusCode / 100 | 0) === 1 || statusCode === 204 || statusCode === 304) {\n    this.body_bytes = 0;\n  }\n  this.state = 'HEADER';\n};\n\nHTTPParser.prototype.shouldKeepAlive = function () {\n  if (this.info.versionMajor > 0 && this.info.versionMinor > 0) {\n    if (this.connection.indexOf('close') !== -1) {\n      return false;\n    }\n  } else if (this.connection.indexOf('keep-alive') === -1) {\n    return false;\n  }\n  if (this.body_bytes !== null || this.isChunked) { // || skipBody\n    return true;\n  }\n  return false;\n};\n\nHTTPParser.prototype.HEADER = function () {\n  var line = this.consumeLine();\n  if (line === undefined) {\n    return;\n  }\n  var info = this.info;\n  if (line) {\n    this.parseHeader(line, info.headers);\n  } else {\n    var headers = info.headers;\n    var hasContentLength = false;\n    var currentContentLengthValue;\n    var hasUpgradeHeader = false;\n    for (var i = 0; i < headers.length; i += 2) {\n      switch (headers[i].toLowerCase()) {\n        case 'transfer-encoding':\n          this.isChunked = headers[i + 1].toLowerCase() === 'chunked';\n          break;\n        case 'content-length':\n          currentContentLengthValue = +headers[i + 1];\n          if (hasContentLength) {\n            // Fix duplicate Content-Length header with same values.\n            // Throw error only if values are different.\n            // Known issues:\n            // https://github.com/request/request/issues/2091#issuecomment-328715113\n            // https://github.com/nodejs/node/issues/6517#issuecomment-216263771\n            if (currentContentLengthValue !== this.body_bytes) {\n              throw parseErrorCode('HPE_UNEXPECTED_CONTENT_LENGTH');\n            }\n          } else {\n            hasContentLength = true;\n            this.body_bytes = currentContentLengthValue;\n          }\n          break;\n        case 'connection':\n          this.connection += headers[i + 1].toLowerCase();\n          break;\n        case 'upgrade':\n          hasUpgradeHeader = true;\n          break;\n      }\n    }\n\n    // if both isChunked and hasContentLength, isChunked wins\n    // This is required so the body is parsed using the chunked method, and matches\n    // Chrome's behavior.  We could, maybe, ignore them both (would get chunked\n    // encoding into the body), and/or disable shouldKeepAlive to be more\n    // resilient.\n    if (this.isChunked && hasContentLength) {\n      hasContentLength = false;\n      this.body_bytes = null;\n    }\n\n    // Logic from https://github.com/nodejs/http-parser/blob/921d5585515a153fa00e411cf144280c59b41f90/http_parser.c#L1727-L1737\n    // \"For responses, \"Upgrade: foo\" and \"Connection: upgrade\" are\n    //   mandatory only when it is a 101 Switching Protocols response,\n    //   otherwise it is purely informational, to announce support.\n    if (hasUpgradeHeader && this.connection.indexOf('upgrade') != -1) {\n      info.upgrade = this.type === HTTPParser.REQUEST || info.statusCode === 101;\n    } else {\n      info.upgrade = info.method === method_connect;\n    }\n\n    if (this.isChunked && info.upgrade) {\n      this.isChunked = false;\n    }\n\n    info.shouldKeepAlive = this.shouldKeepAlive();\n    //problem which also exists in original node: we should know skipBody before calling onHeadersComplete\n    var skipBody;\n    if (compatMode0_12) {\n      skipBody = this.userCall()(this[kOnHeadersComplete](info));\n    } else {\n      skipBody = this.userCall()(this[kOnHeadersComplete](info.versionMajor,\n          info.versionMinor, info.headers, info.method, info.url, info.statusCode,\n          info.statusMessage, info.upgrade, info.shouldKeepAlive));\n    }\n    if (skipBody === 2) {\n      this.nextRequest();\n      return true;\n    } else if (this.isChunked && !skipBody) {\n      this.state = 'BODY_CHUNKHEAD';\n    } else if (skipBody || this.body_bytes === 0) {\n      this.nextRequest();\n      // For older versions of node (v6.x and older?), that return skipBody=1 or skipBody=true,\n      //   need this \"return true;\" if it's an upgrade request.\n      return info.upgrade;\n    } else if (this.body_bytes === null) {\n      this.state = 'BODY_RAW';\n    } else {\n      this.state = 'BODY_SIZED';\n    }\n  }\n};\n\nHTTPParser.prototype.BODY_CHUNKHEAD = function () {\n  var line = this.consumeLine();\n  if (line === undefined) {\n    return;\n  }\n  this.body_bytes = parseInt(line, 16);\n  if (!this.body_bytes) {\n    this.state = 'BODY_CHUNKTRAILERS';\n  } else {\n    this.state = 'BODY_CHUNK';\n  }\n};\n\nHTTPParser.prototype.BODY_CHUNK = function () {\n  var length = Math.min(this.end - this.offset, this.body_bytes);\n  this.userCall()(this[kOnBody](this.chunk, this.offset, length));\n  this.offset += length;\n  this.body_bytes -= length;\n  if (!this.body_bytes) {\n    this.state = 'BODY_CHUNKEMPTYLINE';\n  }\n};\n\nHTTPParser.prototype.BODY_CHUNKEMPTYLINE = function () {\n  var line = this.consumeLine();\n  if (line === undefined) {\n    return;\n  }\n  assert.equal(line, '');\n  this.state = 'BODY_CHUNKHEAD';\n};\n\nHTTPParser.prototype.BODY_CHUNKTRAILERS = function () {\n  var line = this.consumeLine();\n  if (line === undefined) {\n    return;\n  }\n  if (line) {\n    this.parseHeader(line, this.trailers);\n  } else {\n    if (this.trailers.length) {\n      this.userCall()(this[kOnHeaders](this.trailers, ''));\n    }\n    this.nextRequest();\n  }\n};\n\nHTTPParser.prototype.BODY_RAW = function () {\n  var length = this.end - this.offset;\n  this.userCall()(this[kOnBody](this.chunk, this.offset, length));\n  this.offset = this.end;\n};\n\nHTTPParser.prototype.BODY_SIZED = function () {\n  var length = Math.min(this.end - this.offset, this.body_bytes);\n  this.userCall()(this[kOnBody](this.chunk, this.offset, length));\n  this.offset += length;\n  this.body_bytes -= length;\n  if (!this.body_bytes) {\n    this.nextRequest();\n  }\n};\n\n// backward compat to node < 0.11.6\n['Headers', 'HeadersComplete', 'Body', 'MessageComplete'].forEach(function (name) {\n  var k = HTTPParser['kOn' + name];\n  Object.defineProperty(HTTPParser.prototype, 'on' + name, {\n    get: function () {\n      return this[k];\n    },\n    set: function (to) {\n      // hack for backward compatibility\n      this._compatMode0_11 = true;\n      method_connect = 'CONNECT';\n      return (this[k] = to);\n    }\n  });\n});\n\nfunction parseErrorCode(code) {\n  var err = new Error('Parse Error');\n  err.code = code;\n  return err;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}